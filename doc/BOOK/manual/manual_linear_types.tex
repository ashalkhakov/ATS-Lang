\chapter{Programming with Linear Types}

The paradigm of programming with theorem proving plays an indispensable
role in making linear types available for practical use in ATS.  In this
chapter, we present some examples of resource manipulation involving linear
types. In particular, we demonstrate that ATS not only supports flexible
uses of pointers but can also guarantee based on its type system that such
uses are safe.

\section{Safe Memory Access through Pointers}
In ATS, a linear prop is referred to as a {\it view} and a linear type,
which is often a type combined with a view, is referred to as a {\it
viewtype}. A commonly used view constructor is $@$ (infix), which forms a
view $T@L$ when applied to a type $T$ and a memory location $L$. If a proof
of the view $T@L$ is available, then it is guaranteed that a value of the
type $T$ is stored at the location $L$. In the following presentation,
views of the form $T@L$ is often referred to as @-views.  As an example,
the following function templates {\it ptr\_get0} and {\it ptr\_set0}, which reads
and writes through a given pointer, are assigned types containing @-views:
\begin{verbatim}
fun{a:t@ype} ptr_get0 {l:addr} (pf: a @ l | p: ptr l): @(a @ l | a)
fun{a:t@ype} ptr_set0 {l:addr} (pf: a? @ l | p: ptr l, x: a): @(a @ l | void)
\end{verbatim}
Note that $\tptr$ is a type constructor that forms a type $\tptr(L)$ when
applied to a static term $L$ of the sort {\it addr}, and the only value of
the type $\tptr(L)$ is the pointer that points to the location represented
by $L$.

Given a type $T$, the function ${\it ptr\_get0}\langle
T\rangle$ is assigned the following type:
\[\forall l:\saddr.~(T @ l \mid \tptr (l))\timp(T@l \mid T)\]
This type indicates that the function ${\it ptr\_get0}\langle T\rangle$
returns a proof of the view $T@L$ and a value of the type $T$ when applied
to a proof of the view $T@L$ and a pointer of the type $\tptr(L)$ for some
$L$. Intuitively speaking, a proof of the view $T@L$, which is a form of
resource as $T@L$ is linear, is {\it consumed} when it is passed to ${\it
ptr\_get0}\langle T\rangle$, and another proof of the view $T@L$ is
generated when ${\it ptr\_get0}\langle T\rangle$ returns. Notice that a
proof of the view $T@L$ must be returned for otherwise subsequent accesses
to the memory location $L$ become impossible.

Similarly, the function ${\it ptr\_set0}\langle T\rangle$ is
assigned the following type:
\[\forall l:\saddr.~(T? @ l \mid \tptr (l))\timp(T@l \mid void)\]
Note that $T?$ is a type for values of size ${\it sizeof}(T)$ (that are
assumed to be uninitialized).  The function ${\it ptr\_set0}\langle
T\rangle$ returns a proof of the view $T@L$ when applied to a proof of the
view $T?@L$, a pointer of the type $\tptr(L)$ and a value of the type
$T$. The use of the view $T?@L$ indicates that the memory location at $L$
is assumed to be uninitialized when ${\it ptr\_set0}\langle T\rangle$ is
called.

\begin{figure}
\input{DATS/swap0_example.dats}
\caption{A function for swapping memory contents (I)}
\label{figure:swap0_example.dats}
\end{figure}
In Figure~\ref{figure:swap0_example.dats}, a function template {\it swap0}
is implemented for swapping memory contents at two given
locations. Compared to a corresponding implementation in C, the verbosity
of this one in ATS is evident. In particular, the need for {\it threading}
linear proofs through calls to functions that make use of resources often
results in a significant amount of code to be written. We now introduce
some special syntax to significantly alleviate the need for such code.

The function templates ${\it ptr\_get1}$ and ${\it ptr\_set1}$ are given
the following types:
\begin{verbatim}
fun{a:t@ype} ptr_get1 {l:addr} (pf: !a @ l >> a @ l | p: ptr l): a
fun{a:t@ype} ptr_set1 {l:addr} (pf: !a? @ l >> a @ l | p: ptr l, x: a): void
\end{verbatim}
Clearly, for each type $T$, the function
${\it ptr\_get1}\langle T\rangle$ is assigned the following type:
\[
\forall l:\saddr.~(!T@l \gg T@l \mid \tptr(l))\timp T
\]
Given a linear proof ${\it pf}$ of the view $T@L$ for some $L$ and a
pointer $p$ of the type $\tptr(L)$, the function call ${\it
ptr\_get1}\langle T\rangle({\it pf}, p)$ is expected to return a
value of the type $T$. However, the proof ${\it pf}$ is not
consumed. Instead, it is still a proof of the view $T@L$ after the function
call. Similarly, the function
${\it ptr\_set1}\langle T\rangle$ is assigned the following type:
\[
\forall l:\saddr.~(!T?@l \gg T@l \mid \tptr(l), T)\timp\tvoid
\]
Given a linear proof ${\it pf}$ of the view $T?@L$ for some $L$, a pointer
$p$ of the type $\tptr(L)$ and a value $x$ of the type $T$, the function
call ${\it ptr\_set1}\langle T\rangle({\it pf}, p, x)$ is expected to
return the void value while changing the view of ${\it pf}$ from $T?@L$ to
$T@L$.  In general, if $f$ is given a type of the following form for some
views $V_1$ and $V_2$: $$(\ldots,!V_1\gg V_2,\ldots)\timp\ldots$$ then a
function call $f(\ldots,{\it pf},\ldots)$ on some proof ${\it pf}$ of the
view $V_1$ is to change the view of ${\it pf}$ into $V_2$ upon its return.
In the case where $V_1$ and $V_2$ are the same, $!V_1\gg V_2$ can simply be
written as $!V_1$.
\begin{figure}
\input{DATS/swap1_example.dats}
\caption{A function for swapping memory contents (II)}
\label{figure:swap1_example.dats}
\end{figure}
As an example, a function {\it swap1} for swapping the contents at two
given memory locations is implemented in
Figure~\ref{figure:swap1_example.dats}, where the function templates ${\it
ptr\_get1}$ and ${\it ptr\_set1}$ are employed.  Clearly, this
implementation is considerably cleaner when compared to the one in
Figure~\ref{figure:swap0_example.dats}.

\begin{figure}
\input{DATS/swap1_alt_example.dats}
\caption{A function for swapping memory contents (III)}
\label{figure:swap1_alt_example.dats}
\end{figure}
A further simplied implementation of {\it swap1} is given in
Figure~\ref{figure:swap1_alt_example.dats}. Given a pointer $p$ of the type
$\tptr(L)$ for some $L$), $!p$ yields the value stored at the memory
location $L$.  The typechecker first searches for a proof of the view $T@L$
for some $T$ among all available proofs when typechecking $!p$; if such a
proof ${\it pf}$ is found, then $!p$ is essentially elaborated into ${\it
ptr\_get1}({\it pf} \mid p)$ and then typechecked. As $!p$ is a left-value, it can
also be used to form an assignment like $!p := v$. The typechecker
elaborates $!p := v$ into ${\it ptr\_set1}({\it pf} \mid p, v)$ for the sake of
typechecking if a proof of the view $T@L$ can be found among all available
proofs.

\begin{figure}
\begin{verbatim}
dataview array_v (a:t@ype+, int(*size*), addr(*beg*)) =
  | {n:nat} {l:addr}
    array_v_cons (a, n+1, l) of (a @ l, array_v (a, n, l+sizeof a))
  | {l:addr} array_v_nil (a, 0, l)
\end{verbatim}
\caption{}
\label{figure:array_v}
\end{figure}
\section{Dataviews}
A linear dataprop (for classifying linear proofs) is referred to as a {\it
dataview} in ATS. In Figure~\ref{figure:array_v}, the dataview declaration
introduces a view constructor {\it array\_v} and two proof constructors
${\it array\_v\_nil}$ and ${\it array\_v\_cons}$ that are associated with
${\it array\_v}$. The types (or more precisely, props) assigned to these
two proof constructors are given as follows:
\[\begin{array}{rcl}
{\it array\_v\_nil} & : &
\forall a:\staype.\forall l:\saddr. () \timp {\it array\_v} (a, 0, l) \\
{\it array\_v\_cons} & : &
\forall a:\staype.\forall n:\snat.\forall l:\saddr. \\
&&\kern12pt
(a @ l, {\it array\_v} (a, n, l+{\it sizeof}(a))) \timp {\it array\_v} (a, n+1, l) \\
\end{array}\]
Given a type $T$, an integer $I$ and an address $L$, ${\it array\_v}(T, I,
L)$ is a view stating that there are $I$ values of the type $T$ stored (in
a row) at the memory location $L$. A view as such is referred to as an
array view.

\begin{figure}
\begin{verbatim}
prfun array_v_split
  {a:t@ype} {n,i:nat | i <= n} {l:addr} {ofs:int} .<i>.
  (pf_mul: MUL (i, sizeof a, ofs), pf_arr: array_v (a, n, l))
  : @(array_v (a, i, l), array_v (a, n-i, l+ofs)) =
  sif i > 0 then let
    prval array_v_cons (pf1_elt, pf2_arr) = pf_arr
    // pf1_mul : MUL (i-1, sizeof a, ofs - sizeof a)
    prval pf1_mul = mul_add_const {~1} {i, sizeof a} (pf_mul)
    prval (pf1_arr_res, pf2_arr_res) =
      array_v_split {a} {n-1,i-1} (pf1_mul, pf2_arr)
  in
    @(array_v_cons (pf1_elt, pf1_arr_res), pf2_arr_res)
  end else let
    prval MULbas () = pf_mul
  in
    (array_v_nil {a} {l} (), pf_arr)
  end // end of [sif]
// end of [array_v_split]

prfun array_v_unsplit
  {a:t@ype} {n1,n2:nat} {l:addr} {ofs:int} .<n1>. (
    pf_mul: MUL (n1, sizeof a, ofs)
  , pf1_arr: array_v (a, n1, l)
  , pf2_arr: array_v (a, n2, l+ofs)
  ) : array_v (a, n1+n2, l) =
  sif n1 > 0 then let
    prval array_v_cons (pf11_elt, pf12_arr) = pf1_arr
    // pf1_mul : MUL (n1-1, sizeof a, ofs - sizeof a)
    prval pf1_mul = mul_add_const {~1} {n1, sizeof a} (pf_mul)
    prval pf_arr_res = array_v_unsplit {a} (pf1_mul, pf12_arr, pf2_arr)
  in
    array_v_cons (pf11_elt, pf_arr_res)
  end else let
    prval array_v_nil () = pf1_arr; prval MULbas () = pf_mul
  in
    pf2_arr
  end // end of [sif]
// end of [array_v_unsplit]
\end{verbatim}
\caption{Some proof functions for manipulating array views}
\label{figure:array_v_split_unsplit.dats}
\end{figure}
In Figure~\ref{figure:array_v_split_unsplit.dats}, two functions {\it
array\_v\_split} and {\it array\_v\_unsplit} are implmented for
manipulating array views. In essence, given a proof {\it pf} of the view
${\it array\_v} (T, N, L)$ for some type $T$, integer $N$ and address $L$,
${\it array\_v\_split}$ can be called to split {\it pf} (by consuming it)
into a pair of proofs ${\it pf}_1$ and ${\it pf}_2$ of the views ${\it
array\_v} (T, I, L)$ and ${\it array\_v} (T, N-I, L+{\it OFS})$, respectively, for
any natural number $I\leq N$, where $OFS$ equals ${\it sizeof}(T)$
multiplied by $I$. On the other hand, ${\it array\_v\_unsplit}$ can be
called to combine the views of two adjacently allocated arrays into the
view of a single array.

\section{Dataviewtypes}
A linear datatype (for classifying linear values) is referred to as a {\it
dataviewtype} in ATS.

%%% end of \chapter{Programming with Linear Types}
