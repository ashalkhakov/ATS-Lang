<HTML>
<HEAD>
<TITLE>Home Page for ATS-example</TITLE>
<META name="description" content="Home Page for ATS-example">
<META name="keywords" content="">
<LINK REL="stylesheet" HREF="../ATS.css" TYPE="text/css">
</HEAD>
<STYLE TYPE="text/css">
span.comment {color:787878;font-style:italic}
span.extern  {color:A52A2A}
span.keyword {color:000000;font-weight:bold}
span.neuexp  {color:800080}
span.staexp  {color:0000FF}
span.dynexp  {color:E80000}
span.prfexp  {color:009000}
span.stacstdec  {text-decoration:none}
span.stacstuse  {color:0000CF;text-decoration:underline}
span.dyncstdec  {text-decoration:none}
span.dyncstimp  {color:B80000;text-decoration:underline}
span.dyncstuse  {color:B80000;text-decoration:underline}
</STYLE>
<BODY BGCOLOR="#E7CF9E" TEXT="#000000" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
<TABLE WIDTH="100%" BORDER=0 CELLSPACING=0 CELLPADDING=10>
<TR>
<TD CLASS="sidebar">&nbsp;</TD>
<TD CLASS="main">&nbsp;</TD>
</TR>

<TD CLASS="sidebar" VALIGN="top">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=2>
  <TR><TD CLASS="menu"><A HREF="../">Home</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="../TUTORIAL/tutorial.html">Tutorial</TD></TR>
  <TR><TD CLASS="menu"><A HREF="example.html">Examples</A>&nbsp;(<B CLASS="here">new</B>)</TD></TR>
  <TR><TD CLASS="menu"><A HREF="../IMPLEMENTATION/implementation.html">Implementation</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="../RESOURCE/resource.html">Resources</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="../LIBRARY/library.html">Libraries</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="../PAPER/paper.html">Papers</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="../CHANGE/log-of-changes.html">Changes</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="../FAQ.txt">FAQ</A></TD></TR>
  <TR><TD CLASS="menu"><A HREF="https://lists.sourceforge.net/lists/listinfo/ats-lang-users">Mailing List</A></TD></TR>
</TABLE>
</TD>

<TD CLASS="main" VALIGN="top">
<TABLE BORDER=0 CELLPADDING=16>
<CENTER>
<H1>New Examples in ATS/Anairiats</H1>
</CENTER>

<HR SIZE=6 ALIGN=LEFT><P>

In this page, we primarily present some newly constructed examples in ATS
that are relatively short but interesting.

<HR SIZE=6 ALIGN=LEFT><P>

<PRE>
<span class="comment">(*
**
** A proof of the equivalence of two definitions
** of the Ackermann function
**
** Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: December 2, 2009
**
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*

The following two functions are proven to be the same
(in the set-theoretic sense):

fun ack
  (m:int, n:int): int =
  case+ m of
  | 0 =&gt; n+1
  | _ =&gt; begin case+ n of
    | 0 =&gt; ack (m-1, 1) | _ =&gt; ack (m-1, ack (m, n-1))
    end // end of [_]
// end of [ack1]

fun ackf (m: int): int -&lt;cloref1&gt; int = let
  fun helper
    (f: int -&lt;cloref1&gt; int): int -&lt;cloref1&gt; int =
    lam n =&gt; if n = 0 then f (1) else f (helper f (n-1))
  // end of [helper]
in
  case+ m of
  | 0 =&gt; lam n =&gt; n+1 | _ =&gt; helper (ackf (m-1))
end // end of [ackf]

*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><A name="765"><span class="stacstdec">ACK <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> ACK1 <span class="staexp"><span class="keyword">(</span>0<span class="keyword">,</span> n<span class="keyword">,</span> n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">:</span>nat</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">r<span class="keyword">:</span>int</span><span class="keyword">}</span> ACK2 <span class="staexp"><span class="keyword">(</span>m+1<span class="keyword">,</span> 0<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">ACK <span class="keyword">(</span>m<span class="keyword">,</span> 1<span class="keyword">,</span> r<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">,</span>n<span class="keyword">:</span>nat</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">r1<span class="keyword">,</span>r2<span class="keyword">:</span>int</span><span class="keyword">}</span>
    ACK3 <span class="staexp"><span class="keyword">(</span>m+1<span class="keyword">,</span> n+1<span class="keyword">,</span> r2<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>ACK <span class="keyword">(</span>m+1<span class="keyword">,</span> n<span class="keyword">,</span> r1<span class="keyword">)</span><span class="keyword">,</span> ACK <span class="keyword">(</span>m<span class="keyword">,</span> r1<span class="keyword">,</span> r2<span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [ACK]
</span>
<span class="keyword">prfun</span> <span class="prfexp">ack_nat_nat_nat <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m<span class="keyword">,</span>n<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">ACK <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> r<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>r &gt;= 0<span class="keyword">]</span> void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> pf <span class="keyword">of</span>
  <span class="keyword">|</span> ACK1 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> ACK2 pf1 <span class="keyword">=&gt;</span> ack_nat_nat_nat <span class="keyword">(</span>pf1<span class="keyword">)</span>
  <span class="keyword">|</span> ACK3 <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ack_nat_nat_nat pf1</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ack_nat_nat_nat pf2</span>
    <span class="keyword">in</span>
      <span class="comment">// nothing
</span>    <span class="keyword">end</span></span> <span class="comment">// end of [ACK3]
</span><span class="comment">// end of [ack_nat_nat_nat]
</span>
<span class="keyword">sortdef</span> <span class="staexp">int2rel <span class="keyword">=</span> <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">-&gt;</span> prop</span>

<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><A name="1365"><span class="stacstdec">SUCC <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span></span></span></A> <span class="keyword">=</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> SUCC1 <span class="staexp"><span class="keyword">(</span>n<span class="keyword">,</span> n+1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">)</span></span></span>

<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><A name="1422"><span class="stacstdec">HELPER <span class="keyword">(</span>rel<span class="keyword">:</span>int2rel<span class="keyword">,</span> int<span class="keyword">,</span> int<span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">r<span class="keyword">:</span>int</span><span class="keyword">}</span> HELPER1 <span class="staexp"><span class="keyword">(</span>rel<span class="keyword">,</span> 0<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">rel <span class="keyword">(</span>1<span class="keyword">,</span> r<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">r1<span class="keyword">,</span>r2<span class="keyword">:</span>int</span><span class="keyword">}</span>
    HELPER2 <span class="staexp"><span class="keyword">(</span>rel<span class="keyword">,</span> n+1<span class="keyword">,</span> r2<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>HELPER <span class="keyword">(</span>rel<span class="keyword">,</span> n<span class="keyword">,</span> r1<span class="keyword">)</span><span class="keyword">,</span> rel <span class="keyword">(</span>r1<span class="keyword">,</span> r2<span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [HELPER]
</span>
<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><A name="1620"><span class="stacstdec">ACKF <span class="keyword">(</span>int<span class="keyword">,</span> int2rel<span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
  <span class="keyword">|</span> ACKF1 <span class="staexp"><span class="keyword">(</span>0<span class="keyword">,</span> SUCC<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">m<span class="keyword">:</span>nat</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">rel<span class="keyword">:</span>int2rel</span><span class="keyword">}</span>
    ACKF2 <span class="staexp"><span class="keyword">(</span>
      m+1<span class="keyword">,</span> <span class="keyword">lam</span> <span class="keyword">(</span>r1<span class="keyword">:</span>int<span class="keyword">,</span> r2<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=&gt;</span> HELPER <span class="keyword">(</span>rel<span class="keyword">,</span> r1<span class="keyword">,</span> r2<span class="keyword">)</span><span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">ACKF <span class="keyword">(</span>m<span class="keyword">,</span> rel
    <span class="keyword">)</span></span></span> <span class="comment">// end of [ACKF2]
</span><span class="comment">// end of [ACKF]
</span>
<span class="keyword">prfun</span> <span class="prfexp">ACKF_istot
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m<span class="keyword">&gt;.</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>rel<span class="keyword">:</span>int2rel<span class="keyword">]</span> ACKF <span class="keyword">(</span>m<span class="keyword">,</span> rel<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">m <span class="keyword">&gt;</span> 0</span> <span class="keyword">then</span> ACKF2 <span class="keyword">(</span>ACKF_istot <span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> ACKF1 <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">// end of [ACKF_istot]
</span>
<span class="comment">(*
** this lemma means that applying ackf (m) to n gives
** ack (m, n)
*)</span>
<span class="keyword">prfun</span> <span class="prfexp">ackf_ack_lemma1
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>rel<span class="keyword">:</span>int2rel<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m<span class="keyword">,</span>n+1<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">ACKF <span class="keyword">(</span>m<span class="keyword">,</span> rel<span class="keyword">)</span></span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">rel <span class="keyword">(</span>n<span class="keyword">,</span> r<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ACK <span class="keyword">(</span>m<span class="keyword">,</span> n<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">case</span> pf1 <span class="keyword">of</span>
  <span class="keyword">|</span> ACKF1 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">SUCC1 <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf2</span> <span class="keyword">in</span> ACK1 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [ACKF1]
</span>  <span class="keyword">|</span> ACKF2 pf11 <span class="keyword">=&gt;</span> ackf_ack_lemma2 <span class="keyword">(</span>pf11<span class="keyword">,</span> pf2<span class="keyword">)</span>
<span class="comment">// end of [ackf_ack_lemma1]
</span>
<span class="comment">(*
** this lemma means that applying ackf (m) n times to 1 
** gives ack (m+1, n)
*)</span>
<span class="keyword">and</span> ackf_ack_lemma2
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>rel<span class="keyword">:</span>int2rel<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m+1<span class="keyword">,</span>n<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">ACKF <span class="keyword">(</span>m<span class="keyword">,</span> rel<span class="keyword">)</span></span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">HELPER <span class="keyword">(</span>rel<span class="keyword">,</span> n<span class="keyword">,</span> r<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ACK <span class="keyword">(</span>m+1<span class="keyword">,</span> n<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">n <span class="keyword">&gt;</span> 0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">prval</span> <span class="prfexp">HELPER2 <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
    <span class="keyword">prval</span> <span class="prfexp">pf_ack <span class="keyword">=</span> ackf_ack_lemma2 <span class="keyword">(</span>pf1<span class="keyword">,</span> pf21<span class="keyword">)</span></span> <span class="comment">// ACK (m+1, n-1)
</span>    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ack_nat_nat_nat <span class="keyword">(</span>pf_ack<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    ACK3 <span class="keyword">(</span>pf_ack<span class="keyword">,</span> ackf_ack_lemma1 <span class="keyword">(</span>pf1<span class="keyword">,</span> pf22<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// n == 0
</span>    <span class="keyword">prval</span> <span class="prfexp">HELPER1 <span class="keyword">(</span>pf21<span class="keyword">)</span> <span class="keyword">=</span> pf2</span>
  <span class="keyword">in</span>
    ACK2 <span class="keyword">(</span>ackf_ack_lemma1 <span class="keyword">(</span>pf1<span class="keyword">,</span> pf21<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [sif]
</span><span class="comment">// end of [ackf_ack_lemma2]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [Ackermann.dats] *)</span>
</PRE>

<HR SIZE=6 ALIGN=LEFT><P>

<PRE>
<span class="comment">(*
**
** [infprime] proves that for any given natural number [n], there exists a
** prime number [p] that is greater than [n]
**
** Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: October 7, 2009
**
*)</span>

<span class="keyword">propdef</span> <span class="staexp"><A name="219"><span class="stacstdec">PRIME <span class="keyword">(</span>p<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">// if p &gt;= 2
</span>  <span class="keyword">{</span>x<span class="keyword">,</span>y<span class="keyword">:</span>nat <span class="keyword">|</span> x &lt;= y<span class="keyword">}</span> MUL <span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">,</span> p<span class="keyword">)</span> <span class="keyword">-&lt;&gt;</span> <span class="keyword">[</span>x==1<span class="keyword">]</span> void</span></span></A>
<span class="comment">// end of [propdef]
</span>
<span class="comment">(*

extern prval prime2: PRIME (2)
extern prval prime2: PRIME (3)
extern prval prime2: PRIME (5)
extern prval prime2: PRIME (7)

*)</span>

<span class="keyword">extern</span> <span class="comment">// this one is not proven
</span><span class="keyword">prfun</span> <span class="prfexp"><A name="492"><span class="dyncstdec">lemma10 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> n &gt;= 2<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">,</span>q<span class="keyword">:</span>int <span class="keyword">|</span> p &gt;= 2<span class="keyword">]</span> <span class="keyword">(</span>PRIME p<span class="keyword">,</span> MUL <span class="keyword">(</span>p<span class="keyword">,</span> q<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span></span></span></span></A>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><A name="596"><span class="stacstdec">FACT <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span></span></span></A> <span class="keyword">=</span> 
  <span class="keyword">|</span> FACTbas <span class="staexp"><span class="keyword">(</span>0<span class="keyword">,</span> 1<span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">n<span class="keyword">:</span>nat</span><span class="keyword">}</span> <span class="keyword">{</span><span class="staexp">r<span class="keyword">,</span>r1<span class="keyword">:</span>int</span><span class="keyword">}</span> FACTind <span class="staexp"><span class="keyword">(</span>n+1<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp"><span class="keyword">(</span>FACT <span class="keyword">(</span>n<span class="keyword">,</span> r1<span class="keyword">)</span><span class="keyword">,</span> MUL <span class="keyword">(</span>n+1<span class="keyword">,</span> r1<span class="keyword">,</span> r<span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [FACT]
</span>
<span class="keyword">prfun</span> <span class="prfexp">fact_istot
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n<span class="keyword">&gt;.</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>r<span class="keyword">:</span>nat<span class="keyword">]</span> FACT <span class="keyword">(</span>n<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">=</span>
  <span class="keyword">sif</span> <span class="staexp">n == 0</span> <span class="keyword">then</span> FACTbas <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">prval</span> <span class="prfexp">pf_fac <span class="keyword">=</span> fact_istot <span class="staexp"><span class="keyword">{</span>n-1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
    <span class="keyword">prval</span> <span class="prfexp">pf_mul <span class="keyword">=</span> mul_istot <span class="keyword">(</span><span class="keyword">)</span></span><span class="keyword">;</span> <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat <span class="keyword">(</span>pf_mul<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    FACTind <span class="keyword">(</span>pf_fac<span class="keyword">,</span> pf_mul<span class="keyword">)</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [sif]
</span><span class="comment">// end of [fact_istot]
</span>
<span class="keyword">prfun</span> <span class="prfexp">fact_isfun <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>r1<span class="keyword">,</span>r2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>pf1<span class="keyword">:</span> <span class="staexp">FACT <span class="keyword">(</span>n<span class="keyword">,</span> r1<span class="keyword">)</span></span><span class="keyword">,</span> pf2<span class="keyword">:</span> <span class="staexp">FACT <span class="keyword">(</span>n<span class="keyword">,</span> r2<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>r1==r2<span class="keyword">]</span> void</span> <span class="keyword">=</span>
  <span class="keyword">case+</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">of</span>
  <span class="keyword">|</span> <span class="keyword">(</span>FACTbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> FACTbas <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">|</span> <span class="keyword">(</span>FACTind <span class="keyword">(</span>pf11<span class="keyword">,</span> pf12<span class="keyword">)</span><span class="keyword">,</span> FACTind <span class="keyword">(</span>pf21<span class="keyword">,</span> pf22<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fact_isfun <span class="keyword">(</span>pf11<span class="keyword">,</span> pf21<span class="keyword">)</span></span><span class="keyword">;</span> <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_isfun <span class="keyword">(</span>pf12<span class="keyword">,</span> pf22<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="comment">// nothing
</span>    <span class="keyword">end</span></span> <span class="comment">// end of [FACTind, FACTind]
</span><span class="comment">// end of [fact_isfun]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">prfun</span> <span class="prfexp">lemma20 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>r<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>pos <span class="keyword">|</span> i &lt;= n<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n<span class="keyword">&gt;.</span></span>
  <span class="keyword">(</span>pf_fac<span class="keyword">:</span> <span class="staexp">FACT <span class="keyword">(</span>n<span class="keyword">,</span> r<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>k<span class="keyword">:</span>nat<span class="keyword">]</span> MUL <span class="keyword">(</span>k<span class="keyword">,</span> i<span class="keyword">,</span> r<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">prval</span> <span class="prfexp">FACTind <span class="keyword">(</span>pf1_fac<span class="keyword">,</span> pf2_mul<span class="keyword">)</span> <span class="keyword">=</span> pf_fac</span> <span class="comment">// r = n*r1
</span><span class="keyword">in</span>
  <span class="keyword">sif</span> <span class="staexp">i <span class="keyword">&lt;</span> n</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">[</span><span class="staexp">k1<span class="keyword">:</span>int</span><span class="keyword">]</span> pf3_res <span class="keyword">=</span> lemma20 <span class="staexp"><span class="keyword">{</span><span class="keyword">..</span><span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>i<span class="keyword">}</span></span> <span class="keyword">(</span>pf1_fac<span class="keyword">)</span></span> <span class="comment">// pf3_res: k1 * i = r1
</span>    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">[</span><span class="staexp">k<span class="keyword">:</span>int</span><span class="keyword">]</span> pf4_mul <span class="keyword">=</span> mul_istot <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>k1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// k = n*k1
</span>    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat <span class="keyword">(</span>pf4_mul<span class="keyword">)</span></span>
    <span class="keyword">prval</span> <span class="prfexp">pf5_res <span class="keyword">=</span> mul_istot <span class="staexp"><span class="keyword">{</span>k<span class="keyword">,</span>i<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat <span class="keyword">(</span>pf5_res<span class="keyword">)</span></span>
    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_associate <span class="keyword">(</span>pf4_mul<span class="keyword">,</span> pf3_res<span class="keyword">,</span> pf5_res<span class="keyword">,</span> pf2_mul<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    pf5_res
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="keyword">prval</span> <span class="prfexp">pf1_fac_another <span class="keyword">=</span> fact_istot <span class="staexp"><span class="keyword">{</span>n-1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fact_isfun <span class="keyword">(</span>pf1_fac<span class="keyword">,</span> pf1_fac_another<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    mul_commute <span class="keyword">(</span>pf2_mul<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [sif]
</span><span class="keyword">end</span></span> <span class="comment">(* end of [lemma20] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="keyword">prfun</span> <span class="prfexp"><A name="2169"><span class="dyncstdec">infprime <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p<span class="keyword">:</span>int <span class="keyword">|</span> p <span class="keyword">&gt;</span> n<span class="keyword">]</span> PRIME p</span></span></span></A>

<span class="keyword">implement</span> infprime <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">[</span><span class="staexp">r<span class="keyword">:</span>int</span><span class="keyword">]</span> pf_fac <span class="keyword">=</span> fact_istot <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma <span class="keyword">(</span>pf_fac<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">prfun</span> <span class="prfexp">lemma <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>r<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 1<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>n<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>pf_fac<span class="keyword">:</span> <span class="staexp">FACT <span class="keyword">(</span>n<span class="keyword">,</span> r<span class="keyword">)</span></span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>r &gt;= n<span class="keyword">]</span> void</span> <span class="keyword">=</span>
      <span class="keyword">sif</span> <span class="staexp">n &gt;= 2</span> <span class="keyword">then</span> <span class="keyword">let</span>
        <span class="keyword">prval</span> <span class="prfexp">FACTind <span class="keyword">(</span>pf1_fac<span class="keyword">,</span> pf2_mul<span class="keyword">)</span> <span class="keyword">=</span> pf_fac</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma <span class="keyword">(</span>pf1_fac<span class="keyword">)</span></span>
        <span class="keyword">prval</span> <span class="prfexp">pf2_mul <span class="keyword">=</span> mul_commute <span class="keyword">(</span>pf2_mul<span class="keyword">)</span></span>
        <span class="keyword">prval</span> <span class="prfexp">MULind <span class="keyword">(</span>pf3_mul<span class="keyword">)</span> <span class="keyword">=</span> pf2_mul</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat <span class="keyword">(</span>pf3_mul<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="comment">// nothing
</span>      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
        <span class="keyword">prval</span> <span class="prfexp">FACTind <span class="keyword">(</span>pf1_fac<span class="keyword">,</span> pf1_mul<span class="keyword">)</span> <span class="keyword">=</span> pf_fac</span>
        <span class="keyword">prval</span> <span class="prfexp">FACTbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf1_fac</span>
        <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_elim <span class="staexp"><span class="keyword">{</span>1<span class="keyword">,</span>1<span class="keyword">}</span></span> <span class="keyword">(</span>pf1_mul<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="comment">// nothing
</span>      <span class="keyword">end</span></span> <span class="comment">// end of [sif]
</span>   <span class="comment">// end of [lemma]
</span>  <span class="keyword">}</span></span>
  <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">[</span><span class="staexp">p</span><span class="keyword">,</span><span class="staexp">q<span class="keyword">:</span>int</span><span class="keyword">]</span>
    <span class="keyword">(</span>pf_prime<span class="keyword">,</span> pf1_mul<span class="keyword">)</span> <span class="keyword">=</span> lemma10 <span class="staexp"><span class="keyword">{</span>r+1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span></span> <span class="comment">// pf1_mul: p * q = r+1
</span>  <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">sif</span> <span class="staexp">p &lt;= n</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">[</span><span class="staexp">k<span class="keyword">:</span>int</span><span class="keyword">]</span> pf2_mul <span class="keyword">=</span> lemma20 <span class="staexp"><span class="keyword">{</span>n<span class="keyword">,</span>r<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>p<span class="keyword">}</span></span> <span class="keyword">(</span>pf_fac<span class="keyword">)</span></span> <span class="comment">// pf2_mul: k * p = r
</span>    <span class="keyword">prval</span> <span class="prfexp">pf2_mul <span class="keyword">=</span> mul_negate <span class="keyword">(</span>pf2_mul<span class="keyword">)</span></span> <span class="comment">// pf2_mul: ~k * p = ~r
</span>    <span class="keyword">prval</span> <span class="prfexp">pf2_mul <span class="keyword">=</span> mul_commute <span class="keyword">(</span>pf2_mul<span class="keyword">)</span></span> <span class="comment">// pf2_mul: p * ~k = ~r
</span>    <span class="keyword">prval</span> <span class="prfexp">pf3_mul <span class="keyword">=</span> mul_distribute <span class="keyword">(</span>pf1_mul<span class="keyword">,</span> pf2_mul<span class="keyword">)</span></span> <span class="comment">// pf3_mul: p * (q-k) = 1
</span>    <span class="keyword">prval</span> <span class="prfexp">pf3_mul <span class="keyword">=</span> mul_commute <span class="keyword">(</span>pf3_mul<span class="keyword">)</span></span> <span class="comment">// pf3_mul : (q-k) * p = 1
</span>  <span class="keyword">in</span>
    <span class="keyword">sif</span> <span class="staexp">q <span class="keyword">&gt;</span> k</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">MULind pf4_mul <span class="keyword">=</span> pf3_mul</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat <span class="keyword">(</span>pf4_mul<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="comment">// nothing
</span>    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">sif</span> <span class="staexp">q <span class="keyword">&lt;</span> k</span> <span class="keyword">then</span> <span class="keyword">let</span>
      <span class="keyword">prval</span> <span class="prfexp">pf3_mul <span class="keyword">=</span> mul_negate <span class="keyword">(</span>pf3_mul<span class="keyword">)</span></span> <span class="comment">// pf3_mul: (k-q) * p = 1
</span>      <span class="keyword">prval</span> <span class="prfexp">MULind pf4_mul <span class="keyword">=</span> pf3_mul</span>
      <span class="keyword">prval</span> <span class="prfexp"><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> mul_nat_nat_nat <span class="keyword">(</span>pf4_mul<span class="keyword">)</span></span>
    <span class="keyword">in</span>
      <span class="comment">// nothing
</span>    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span> <span class="comment">// q = k
</span>      <span class="keyword">prval</span> <span class="prfexp">MULbas <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pf3_mul</span> <span class="keyword">in</span> <span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [sif]
</span>  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>
    <span class="comment">// nothing
</span>  <span class="keyword">end</span><span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>p <span class="keyword">&gt;</span> n<span class="keyword">]</span> void</span></span> <span class="comment">// end of [prval]
</span><span class="keyword">in</span>
  <span class="staexp"><span class="keyword">#[</span>p <span class="keyword">|</span></span> pf_prime<span class="keyword">]</span>
<span class="keyword">end</span> <span class="comment">// end of [infprime]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [infprime.dats] *)</span>
</PRE>

<HR SIZE=6 ALIGN=LEFT><P>

<PRE>
<span class="comment">(*
**
** A proof of the pigeonhole principle in ATS
**
**
** Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: September 28, 2009
**
*)</span>

<span class="comment">(*

What is encoded and proven in ATS is the following formulation of
pigeonhole principle:

Let P be a relation on pairs of integers and m and n be two naturnal
numbers satisfying m &gt; n and n &gt;= 1. If there exists a natural number
j &lt; n for each given naturnal number i &lt; m such that P (i, j) holds,
then there exists i1, i2 and j satisfying 0 &lt;= i1 &lt; i2 &lt; m and j &lt; n
such that both P (i1, j) and P (i2, j) hold.

*)</span>

<span class="keyword">sortdef</span> <span class="staexp">int2rel <span class="keyword">=</span> <span class="keyword">(</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">-&gt;</span> prop</span> <span class="comment">// for binary relations on integers
</span>
<span class="keyword">prfun</span> <span class="prfexp">pigeonhole
  <span class="staexp"><span class="keyword">{</span>P<span class="keyword">:</span> int2rel<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> m <span class="keyword">&gt;</span> n<span class="keyword">;</span> n &gt;= 1<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">.&lt;</span>m<span class="keyword">&gt;.</span></span> <span class="keyword">(</span>
    fpf<span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> m<span class="keyword">}</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">-&gt;</span> <span class="keyword">[</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> j <span class="keyword">&lt;</span> n<span class="keyword">]</span> P <span class="keyword">(</span>i<span class="keyword">,</span> j<span class="keyword">)</span></span>
  <span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>i1<span class="keyword">,</span>i2<span class="keyword">,</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> i1 <span class="keyword">&lt;</span> i2<span class="keyword">;</span> i2 <span class="keyword">&lt;</span> m<span class="keyword">]</span> <span class="keyword">(</span>P <span class="keyword">(</span>i1<span class="keyword">,</span> j<span class="keyword">)</span><span class="keyword">,</span> P <span class="keyword">(</span>i2<span class="keyword">,</span> j<span class="keyword">)</span><span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">sif</span> <span class="staexp">n &gt;= 2</span> <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">x<span class="keyword">:</span>int</span><span class="keyword">]</span> pf0 <span class="keyword">=</span> fpf <span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">dataprop</span> <span class="prfexp"><span class="staexp"><A name="883"><span class="stacstdec">P1 <span class="keyword">(</span>i<span class="keyword">:</span>int<span class="keyword">,</span> int<span class="keyword">)</span></span></span></A> <span class="keyword">=</span>
    <span class="keyword">|</span> P1r1 <span class="staexp"><span class="keyword">(</span>i<span class="keyword">,</span> 0<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">P <span class="keyword">(</span>i<span class="keyword">,</span> x<span class="keyword">)</span></span>
    <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">x<span class="keyword">&gt;</span>0</span><span class="keyword">}</span> P1r2 <span class="staexp"><span class="keyword">(</span>i<span class="keyword">,</span> x-1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">P <span class="keyword">(</span>i<span class="keyword">,</span> 0<span class="keyword">)</span></span>
    <span class="keyword">|</span> <span class="keyword">{</span><span class="staexp">j<span class="keyword">:</span>int</span> <span class="keyword">|</span> <span class="staexp">j <span class="keyword">&gt;</span> 0</span><span class="keyword">;</span> <span class="staexp">j &lt;&gt; x</span><span class="keyword">}</span> P1r3 <span class="staexp"><span class="keyword">(</span>i<span class="keyword">,</span> j-1<span class="keyword">)</span></span> <span class="keyword">of</span> <span class="staexp">P <span class="keyword">(</span>i<span class="keyword">,</span> j<span class="keyword">)</span></span></span>
  <span class="keyword">prfn</span> <span class="prfexp">fpf1 <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> m-1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> j <span class="keyword">&lt;</span> n-1<span class="keyword">]</span> P1 <span class="keyword">(</span>i<span class="keyword">,</span> j<span class="keyword">)</span></span> <span class="keyword">=</span> <span class="keyword">let</span>
    <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">j<span class="keyword">:</span>int</span><span class="keyword">]</span> pf <span class="keyword">=</span> fpf <span class="staexp"><span class="keyword">{</span>i<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span>
  <span class="keyword">in</span>
    <span class="keyword">sif</span> <span class="staexp">j == 0</span> <span class="keyword">then</span>
      <span class="keyword">(</span><span class="keyword">sif</span> <span class="staexp">x == 0</span> <span class="keyword">then</span> P1r1 <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">else</span> P1r2 <span class="keyword">(</span>pf<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">else</span>
      <span class="keyword">(</span><span class="keyword">sif</span> <span class="staexp">j == x</span> <span class="keyword">then</span> P1r1 <span class="keyword">(</span>pf<span class="keyword">)</span> <span class="keyword">else</span> P1r3 <span class="keyword">(</span>pf<span class="keyword">)</span><span class="keyword">)</span>
    <span class="comment">// end of [sif]
</span>  <span class="keyword">end</span></span> <span class="comment">// end of [fpf1]
</span>  <span class="keyword">val</span> <span class="keyword">[</span><span class="staexp">i1</span><span class="keyword">,</span><span class="staexp">i2</span><span class="keyword">,</span><span class="staexp">j<span class="keyword">:</span>int</span><span class="keyword">]</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span> <span class="keyword">=</span> pigeonhole <span class="staexp"><span class="keyword">{</span>P1<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>m-1<span class="keyword">,</span>n-1<span class="keyword">}</span></span> <span class="keyword">(</span>fpf1<span class="keyword">)</span>
<span class="keyword">in</span>
  <span class="keyword">case+</span> pf1 <span class="keyword">of</span>
  <span class="keyword">|</span> P1r1 <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf0<span class="keyword">)</span>
  <span class="keyword">|</span> P1r2 <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> pf2 <span class="keyword">of</span>
    <span class="keyword">|</span> P1r1 pf2 <span class="keyword">=&gt;</span> <span class="keyword">(</span>pf2<span class="keyword">,</span> pf0<span class="keyword">)</span> <span class="keyword">|</span> P1r2 pf2 <span class="keyword">=&gt;</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P1r2]
</span>  <span class="keyword">|</span> P1r3 <span class="keyword">(</span>pf1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">begin</span> <span class="keyword">case+</span> pf2 <span class="keyword">of</span>
    <span class="keyword">|</span> P1r1 pf2 <span class="keyword">=&gt;</span> <span class="keyword">(</span>pf2<span class="keyword">,</span> pf0<span class="keyword">)</span> <span class="keyword">|</span> P1r3 pf2 <span class="keyword">=&gt;</span> <span class="keyword">(</span>pf1<span class="keyword">,</span> pf2<span class="keyword">)</span>
    <span class="keyword">end</span> <span class="comment">// end of [P1r3]
</span><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">// n = 1
</span>  <span class="keyword">(</span>fpf <span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> fpf <span class="staexp"><span class="keyword">{</span>1<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [pigenhole]
</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [pigeonhole.dats] *)</span>
</PRE>

<HR SIZE=6 ALIGN=LEFT><P>
This page is maintained by
<a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
As always,
<a href="mailto:hwxi@cs.bu.edu">your comments are welcome</a>.

<HR SIZE=6 ALIGN=LEFT>
<a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=205722&amp;type=2" align=right width="125" height="37" border="0" alt="SourceForge.net Logo"/></a>

</TABLE>
</TD>

</BODY>
</HTML>
