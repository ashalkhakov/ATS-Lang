<chapter id="cairo_basics">
<title>ATS/Cario Basics</title>
<para>

ATS is a rich programming language equipped with a highly expressive type
system for specifying and enforcing program invariants. In particular, both
dependent and linear types are available in ATS to support practical
programming.  ATS/Cairo is the API in ATS for

<ulink url="http://www.cairographics.org">cairo</ulink>,

a comprehensive drawing package supporting 2D graphics. There are already
many on-line tutorials on using cairo (e.g., <ulink
url="http://www.cairographics.org/tutorial">this one</ulink>), and the
reader may want to use them as references when studying the current one,
which focuses on using types in ATS to facilitate safe and reliable
programming with cairo.

</para>

<sect1 id="hello_world_example">

<title>A Simple Example: Hello, world!</title>
<para>
The first program we present in this tutorial is given as follows:
<informalexample id="tutprog_hw">
&tutprog_hw;
</informalexample>
The functions in the cairo package are declared in the following file:

<ulink
url="https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/contrib/cairo/SATS/cairo.sats">
<filename>contrib/cairo/SATS/cairo.sats</filename>
</ulink>.

Note that in this tutorial, a file name, if relative, is always relative to
the ATS home directory (stored in the environment variable ATSHOME) unless
it is specified otherwise.

</para>

<para> Suppose that the presented program is stored in a file named <ulink
url="CODE/tutprog_hw_dats.html"><filename>tutprog_hw.dats</filename></ulink>. Then
the following command can be issued to compile the program to generate an
executable <filename>tutprog_hw</filename>:
<informalexample><programlisting>
atscc -o tutprog_hw tutprog_hw.dats `pkg-config cairo --cflags --libs`
</programlisting></informalexample>
By executing <filename>tutprog_hw</filename>, we generate a PNG image file
<ulink
url="IMAGE/tutprog_hw.png"><filename>tutprog_hw.png</filename></ulink>, which
is included as follows:
</para>

<para>
<inlinemediaobject>
<imageobject>
<imagedata fileref="IMAGE/tutprog_hw.png" format="PNG"/>
</imageobject>
</inlinemediaobject>
</para>

<para>
One can also use tools such <emphasis>eog</emphasis> and
<emphasis>gthumb</emphasis> to view PNG files.
</para>

<para>

We now give a brief explanation on the program in
<ulink
url="CODE/tutprog_hw_dats.html"><filename>tutprog_hw.dats</filename></ulink>.
We first create a cairo surface for drawing:
<informalexample><programlisting>
  val surface = // create a surface for drawing
    cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 250, 80)
</programlisting></informalexample>
We then use the surface to create a cairo context:
<informalexample><programlisting>
  val cr = cairo_create (surface)
</programlisting></informalexample>
We choose a font face and set the font size to 32.0:
<informalexample><programlisting>
  val () = cairo_select_font_face
    (cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD)
  val () = cairo_set_font_size (cr, 32.0)
</programlisting></informalexample>

Imagine that we are holding a pen. We set the color of the pen
to blue:
<informalexample><programlisting>
  // the call [cairo_set_source_rgb] sets the color to blue
  val () = cairo_set_source_rgb (cr, 0.0(*r*), 0.0(*g*), 1.0(*b*))
</programlisting></informalexample>

We now move the pen to the postion (10.0, 50.0):
<informalexample><programlisting>
  val () = cairo_move_to (cr, 10.0, 50.0)
</programlisting></informalexample>
and use the pen to write down the text "Hello, world!":
<informalexample><programlisting>
  val () = cairo_show_text (cr, "Hello, world!")
</programlisting></informalexample>

At this point, we have finished drawing. We store the image drawn on the
surface into a PNG file:
<informalexample><programlisting>
  val status = cairo_surface_write_to_png (surface, "tutprog_hw.png")
</programlisting></informalexample>

We now enter the cleanup phase, closing both the surface and the context:
<informalexample><programlisting>
  val () = cairo_surface_destroy (surface) // a type error if omitted
  val () = cairo_destroy (cr) // a type error if omitted
</programlisting></informalexample>

In case of a failure, we report it:
<informalexample><programlisting>
  // in case of a failure ...
  val () = assert_errmsg (status = CAIRO_STATUS_SUCCESS, #LOCATION)
</programlisting></informalexample>
</para>

<para>

On the surface, it seems that using cairo functions in ATS is nearly
identical to using them in C (modulo syntatical difference). However, what
happens at the level of typechecking in ATS is far more sophisticated than
in C. In particular, linear types are assigned to cairo objects (e.g.,
contexts, surfaces, patterns, font faces) in ATS to allow them to be
tracked statically, that is, at compile-time, preventing potential memory
mismanagement. For instance, if the following line:
<informalexample>
<programlisting>
  val () = cairo_surface_destroy (surface) // a type error if omitted
</programlisting>
</informalexample>
is removed from the program in <ulink
url="CODE/tutprog_hw_dats.html"><filename>tutprog_hw.dats</filename></ulink>, then
a type-error message is issued at compile-time to indicate that the
resource <emphasis>surface</emphasis> is not properly freed.
A message as such can be of great value in practice for correcting
potential memory leaks that may otherwise readily go unnoticed.  ATS is a
programming language that distinguishes itself in its practical and
effective support for precise resource management.

</para>

</sect1><!-- hello_world_example -->

<sect1 id = "cairo_object_types">
<title>
Types for Some Objects in Cairo
</title>
<para>
The type for cairo drawing contexts in ATS is declared as follows:
<informalexample><programlisting>
absviewtype cairo_ref (l:addr) // = cairo_t*
</programlisting></informalexample>

The type <emphasis>cairo_ref(null)</emphasis> is just for a null pointer.
Given an address <emphasis>L</emphasis> that is not null, the type
<emphasis>cairo_ref(L)</emphasis> is for a reference to a cairo context
located at <emphasis>L</emphasis>. We introduce an abbreviation
<emphasis>cairo_ref1</emphasis> as follows:

<informalexample><programlisting>
viewtypedef cairo_ref1 = [l:addr | l > null] cairo_ref l
</programlisting></informalexample>

Therefore, <emphasis>cairo_ref1</emphasis> essentially represents a type
<emphasis>cairo_ref(L)</emphasis> for some unknown <emphasis>L</emphasis>
that is not null. Similarly, we have the following types in ATS for objects
representing cairo surfaces, cairo patterns, and cairo font faces:

<informalexample><programlisting>
absviewtype cairo_surface_ref (l:addr) // = cairo_surface_t*
viewtypedef cairo_surface_ref1 = [l:addr | l > null] cairo_surface_ref l

absviewtype cairo_pattern_ref (l:addr) // = cairo_pattern_t*
viewtypedef cairo_pattern_ref1 = [l:addr | l > null] cairo_pattern_ref l

absviewtype cairo_font_face_ref (l:addr) // = cairo_font_face_t*
viewtypedef cairo_font_face_ref1 = [l:addr | l > null] cairo_font_face_ref l
</programlisting></informalexample>

The above types for objects in cairo are all reference-counted. In other
words, there is a reference count in each object that is assgined one of
these types. When such an object is created, the initial count is 1. This
count can increase or decrease depending on operations performed on the
object, and the object is freed once the count drops to 0. In ATS, we can
employ linear typs to track reference counts. Compared to various other
APIs for cairo, the ability to track reference counts statically, that is,
at compile-time, is arguably the greatest benefit one receives when
programming with ATS/Cairo.

</para>

</sect1><!-- cairo_object_types -->

<!-- ****** ****** -->

<sect1 id = "cairo_function_types">
<title>
Types for Some Functions in Cairo
</title>
<para>

We now present some functions in cairo and the types assigned to them in
ATS.  These types often reveal a lot more information about the functions
to which they are assigned than their counterparts in C.

</para>
<para>

The following function <emphasis>cairo_destroy</emphasis> is for
destroying a cairo context:

<informalexample><programlisting>
fun cairo_destroy (cr: cairo_ref1): void
</programlisting></informalexample>

What this funtion really does is to decrease by 1 the reference count of
the object referred to by its argument. The object is freed, that is, truly
destroyed only if the new count becomes 0. Because
<emphasis>cairo_ref1</emphasis> is a linear type (or viewtype in ATS),
if <emphasis>cairo_destroy(cr)</emphasis> is called, then
<emphasis>cr</emphasis> can no longer be used as it is consumed: a linear
value, that is, a value of a linear type, must be used once and only
once. This point is made much clearer in the following example,
where the function <emphasis>cairo_reference</emphasis> is presented:

<informalexample><programlisting>
fun cairo_reference {l:agz} (cr: !cairo_ref l): cairo_ref l
</programlisting></informalexample>

First, <emphasis>agz</emphasis> is a sort defined as follows:

<informalexample><programlisting>
sortdef agz = {l:addr | l > null}
</programlisting></informalexample>

Therefore, <emphasis>{l:agz}</emphasis> is simply a shorthand for
<emphasis>{l:addr | l > null}</emphasis>. What
<emphasis>cairo_reference</emphasis> does is to increase the reference
count of its argument by 1. In the type assigned to
<emphasis>cairo_reference</emphasis>, the symbol <emphasis>!</emphasis> in
front of <emphasis>cairo_ref</emphasis> indicates that the argument of the
function <emphasis>cairo_reference</emphasis> is not consumed by a call to
the function (and thus it can be used later). Clearly, the type also
indicates that the value returned by
<emphasis>cairo_reference(cr)</emphasis> is a reference pointing to the
same location as <emphasis>cr</emphasis> does. If the symbol
<emphasis>!</emphasis> was omitted, the function would consume a cairo
context and then return one, thus preserving reference count.
</para>

<para>
The following function <emphasis>cairo_create</emphasis> is for creating
a cairo context:
<informalexample><programlisting>
fun cairo_create {l:agz} (sf: !cairo_surface_ref l): cairo_ref1
</programlisting></informalexample>
</para>

<para>
The type of this function indicates that it takes a reference to a cairo
surface and returns a reference to a cairo context; the symbol
<emphasis>!</emphasis> indicates that the reference to the surface is
preserved and thus is still available after the function being called; if
the reference to the surface is no longer needed, it is necessary to
call the function <emphasis>cairo_surface_destroy</emphasis> on the
reference.
</para>

<para>
We can have another function <emphasis>cairo_create0</emphasis> of the
following type for creating a cairo context:
<informalexample><programlisting>
fun cairo_create0 {l:agz} (sf: cairo_surface_ref l): cairo_ref1
</programlisting></informalexample>
After calling <emphasis>cairo_create0</emphasis> on a cairo surface, the
surface is consumed, that is, it is no longer available for subsequent use,
and therefore there is no need to destroy it by calling
<emphasis>cairo_surface_destroy</emphasis>. If both
<emphasis>cairo_create</emphasis> and <emphasis>cairo_create0</emphasis>
are provided to the programmer in a language like C, it can readily lead
to memory leaks as one may mistakenly use
<emphasis>cairo_create0</emphasis>
in place of <emphasis>cairo_create</emphasis>. This, however, is not an
issue in ATS as such an error is surely caught during typechecking.
</para>

<para>
As various functions can modify the cario context they use, it is often
necessary to save the state of a context so that the saved state can be
restored at a later point. The functions for saving and restoring the state
of a cairo context are given as follows:

<informalexample><programlisting>
fun cairo_save {l:agz} (cr: !cairo_ref l): (cairo_save_v l | void)
fun cairo_restore {l:agz} (pf: cairo_save_v l | cr: !cairo_ref l): void
</programlisting></informalexample>

The view constructor <emphasis>cairo_save_v</emphasis> is declared to
be abstract:

<informalexample><programlisting>
absview cairo_save_v (l:addr) // abstract view generated by cairo_save
</programlisting></informalexample>

The simple idea behind <emphasis>cairo_save_v</emphasis> is this: Given a
reference of the type <emphasis>cairo_ref(L)</emphasis> for some address
<emphasis>L</emphasis>, a call to <emphasis>cairo_save</emphasis> on the
reference returns a linear proof of the view
<emphasis>cairo_save_v(L)</emphasis>, and this proof must be consumed at
some point by a call to <emphasis>cairo_restore</emphasis> on a reference
of the type <emphasis>cairo_ref(L)</emphasis>. In other words, calls to
<emphasis>cairo_save</emphasis> and <emphasis>cairo_restore</emphasis> are
guaranteed to be properly balanced in a well-typed ATS program.  This is
evidently a desirable feature given that balancing such calls can often be
a onerous burden for the programmer programming in languages like C.

</para>

</sect1><!-- cairo_function_types -->

<!-- ****** ****** -->

<sect1>
<title>Drawing Lines</title>
<para>
In cairo, drawing often starts with the construction of a path consisting of
a sequence of points. For example, the function
<emphasis>draw_triangle</emphasis> for drawing a path connecting
three points is given as follows:

<informalexample><programlisting>
fun draw_triangle {l:agz} (
    cr: !cairo_ref l
  , x0: double, y0: double, x1: double, y1: double, x2: double, y2: double
  ) : void = () where {
  val () = cairo_move_to (cr, x0, y0)
  val () = cairo_line_to (cr, x1, y1)
  val () = cairo_line_to (cr, x2, y2)
  val () = cairo_close_path (cr)
} // end of [draw_triangle]
</programlisting></informalexample>

The functions involved in the body of
<emphasis>draw_triangle</emphasis> are assigned the following types in ATS:

<informalexample><programlisting>
fun cairo_move_to {l:agz} (cr: !cairo_ref l, x: double, y: double): void

fun cairo_line_to {l:agz} (cr: !cairo_ref l, x: double, y: double): void

fun cairo_close_path {l:agz} (cr: !cairo_ref l): void
</programlisting></informalexample>

When called, <emphasis>cairo_move_to</emphasis> starts a new (sub)path
whose initial point is (x, y) and <emphasis>cairo_line_to</emphasis>
connects the current point on the current path to (x, y) and then set (x,
y) to be the current point. The function
<emphasis>cairo_close_path</emphasis> simply adds a segment connecting the
current point to the initial point of the current (sub)path.

There is also a function <emphasis>cairo_rel_line_to</emphasis> of the
following type:
<informalexample><programlisting>
fun cairo_rel_line_to {l:agz} (cr: !cairo_ref l, x: double, y: double): void
</programlisting></informalexample>
This function is similar to <emphasis>cairo_line_to</emphasis> except for
(x, y) being relative to the current point on the current (sub)path.
</para>

<para> Once a path is constructed, <emphasis>cairo_stroke</emphasis> can be
called to draw line segments along the path.  There are a few line
attributes that can be set in cairo. For instance, the styles of line cap
and line join as well as the width of line can be set by the following
functions:

<informalexample><programlisting>
fun cairo_set_line_cap {l:agz} (cr: !cairo_ref l, line_cap: cairo_line_cap_t): void

fun cairo_set_line_join {l:agz} (cr: !cairo_ref l, line_join: cairo_line_join_t): void

fun cairo_set_line_width {l:agz} (cr: !cairo_ref l, width: double): void
</programlisting></informalexample>

The following styles of line cap are supported:
<informalexample><programlisting>
CAIRO_LINE_CAP_BUTT
CAIRO_LINE_CAP_ROUND
CAIRO_LINE_CAP_SQUARE
</programlisting></informalexample>
and the following lines, from left to right, are drawn according to these
styles, respectively:
</para>

<para>
<inlinemediaobject>
<imageobject>
<imagedata fileref="IMAGE/tutprog_linecap.png" format="PNG"/>
</imageobject>
</inlinemediaobject>
</para>

<para>
The following styles of line join are supported:
<informalexample><programlisting>
CAIRO_LINE_JOIN_MITER
CAIRO_LINE_JOIN_ROUND
CAIRO_LINE_JOIN_BEVEL
</programlisting></informalexample>
and the following triangles, from left to right, are drawn according to these
styles, respectively:
</para>

<para>
<inlinemediaobject>
<imageobject>
<imagedata fileref="IMAGE/tutprog_linejoin.png" format="PNG"/>
</imageobject>
</inlinemediaobject>
</para>

<para>
There is also a function <emphasis>cairo_set_dash</emphasis> for setting up
line dash pattern.
</para>

<para>
Please find in <ulink
url="CODE/tutprog_triangle_dats.html"><filename>tutprog_triangle.dats</filename></ulink>
a program with a GUI interface that employes the function
<emphasis>draw_triangle</emphasis> to draw randomly generated triangles.
</para>

</sect1><!-- cairo_drawing_line -->

<!-- ****** ****** -->

<sect1 id = "cairo_drawing_circle_square">
<title>Drawing Rectangles and Circles</title>

<para>
We are to generate an image showing a white circle inside a black square:
</para>

<para>
<inlinemediaobject>
<imageobject>
<imagedata fileref="IMAGE/tutprog_sqrcirc.png" format="PNG"/>
</imageobject>
</inlinemediaobject>
</para>

<para>
The main function for drawing this image is given as follows:

<informalexample><programlisting>
fun draw_sqrcirc {l:agz}
  (cr: !cairo_ref l): void = let
  val () = cairo_rectangle (cr, ~0.5, ~0.5, 1.0, 1.0)
  val () = cairo_set_source_rgb (cr, 0.0, 0.0, 0.0) // black color
  val () = cairo_fill (cr)
  val () = cairo_arc (cr, 0.0, 0.0, 0.5, 0.0, 2*PI)
  val () = cairo_set_source_rgb (cr, 1.0, 1.0, 1.0) // white color
  val () = cairo_fill (cr)
in
  // nothing
end // end of [draw_sqrcirc]
</programlisting></informalexample>

At this moment, let us assume that the square is centered at the position
(0, 0) and the length of each of its sides is 1. Therefore, the upper left
corner of the square is at (-0.5, -0.5) as x-axis and y-axis increase from
left to right and from top to bottom, respectively. We first draw
as follows a rectangle which happens to be a square:

<informalexample><programlisting>
  val () = cairo_rectangle (cr, ~0.5, ~0.5, 1.0, 1.0)
</programlisting></informalexample>

The function <emphasis>cairo_rectangle</emphasis> is given the following
type in ATS:

<informalexample><programlisting>
fun cairo_rectangle {l:agz} (
  cr: !cairo_ref l, x: double, y: double, width: double, height: double
) : void // end of [cairo_rectangle]
</programlisting></informalexample>

When called, this function draws a rectangle whose width and height are
<emphasis>width</emphasis> and <emphasis>height</emphasis>,
respectively, and whose upper left corner is located at (x, y).

We then fill the rectangle with black color:
<informalexample><programlisting>
  val () = cairo_set_source_rgb (cr, 0.0, 0.0, 0.0) // black color
  val () = cairo_fill (cr)
</programlisting></informalexample>
</para>

<para>
We next draw a circle of radius 0.5 whose center is at (0.0, 0.0):
<informalexample><programlisting>
  val () = cairo_arc (cr, 0.0, 0.0, 0.5, 0.0, 2*PI)
</programlisting></informalexample>

The function <emphasis>cairo_arc</emphasis> is given the following
type in ATS:

<informalexample><programlisting>
fun cairo_arc {l:agz} (
  cr: !cairo_ref l
, xc: double, yc: double, rad: double, angle1: double, angle2: double
) : void // end of [cairo_arc]
</programlisting></informalexample>

When called, this function draws an arc that is part of the circle
whose radius equals <emphasis>radius</emphasis> and whose center is
at (xc, yc). The arc begins at the angle <emphasis>angle1</emphasis>
and ends at the angle <emphasis>angle2</emphasis>, where clockwise
rotation is assumed. If counterclockwise rotation is needed, the following
function can be used instead:

<informalexample><programlisting>
fun cairo_arc_negative {l:agz} (
  cr: !cairo_ref l
, xc: double, yc: double, rad: double, angle1: double, angle2: double
) : void // end of [cairo_arc_negative]
</programlisting></informalexample>

Lastly, we fill the circle with white color:
<informalexample><programlisting>
  val () = cairo_set_source_rgb (cr, 1.0, 1.0, 1.0) // white color
  val () = cairo_fill (cr)
</programlisting></informalexample>
</para>

<para>
We can now make a call to the function <emphasis>draw_sqrcirc</emphasis>
to generate a PNG file:
<informalexample><programlisting>
implement main () = () where {
//
  val W = 250 and H = 250
//
  val surface = // create a surface for drawing
    cairo_image_surface_create (CAIRO_FORMAT_ARGB32, W, H)
  val cr = cairo_create (surface)
//
  val WH = min (W, H)
  val WH = double_of (WH)
  val (pf0 | ()) = cairo_save (cr)
  val () = cairo_translate (cr, WH/2, WH/2)
  val () = cairo_scale (cr, WH, WH)
  val () = draw_sqrcirc (cr)
  val () = cairo_restore (pf0 | cr)
//
  val status = cairo_surface_write_to_png (surface, "tutprog_sqrcirc.png")
  val () = cairo_surface_destroy (surface) // a type error if omitted
  val () = cairo_destroy (cr) // a type error if omitted
//
  // in case of a failure ...
  val () = assert_errmsg (status = CAIRO_STATUS_SUCCESS, #LOCATION)
} // end of [main]
</programlisting></informalexample>
The functions <emphasis>cairo_translate</emphasis>
and <emphasis>cairo_scale</emphasis> are given the following types in ATS:

<informalexample><programlisting>
fun cairo_translate
  {l:agz} (cr: !cairo_ref l, x: double, y: double): void
// end of [cairo_translate]

fun cairo_scale
  {l:agz} (cr: !cairo_ref l, sx: double, sy: double): void
// end of [cairo_scale]
</programlisting></informalexample>

When called, <emphasis>cairo_translate</emphasis> creates a new coordinate
system by shifting the origin of the current coordinate system to the point
(x, y) and <emphasis>cairo_scale</emphasis> creates a new coordinate
system whose x-unit and y-unit are sx and sy times the x-unit and y-unit of
the current system, respectively.
</para>

<para>

For the entirety of the code used in this section, please see
<ulink url="CODE/tutprog_sqrcirc_dats.html"><filename>tutprog_sqrcirc.dats</filename></ulink>.

</para>

<para>
For a more elaborate example involving circles, please see
<ulink
url="CODE/illucircmot_dats.html"><filename>illucircmot.dats</filename></ulink>,
which generates the following interesting image:
</para>

<para>
<inlinemediaobject>
<imageobject><imagedata fileref="IMAGE/illucircmot.png" format="PNG"/></imageobject>
</inlinemediaobject>
</para>

<para>
For a more elabortate example involving squares and circles, please see
<ulink
url="CODE/illuwavy_dats.html"><filename>illuwavy.dats</filename></ulink>,
which generates the following interesting image:
</para>

<para>
<inlinemediaobject>
<imageobject><imagedata fileref="IMAGE/illuwavy.png" format="PNG"/></imageobject>
</inlinemediaobject>
</para>

</sect1><!-- cairo_drawing_rectangle_circle -->

<sect1 id="cairo_drawing_text">
<title>Drawing Text</title>

<para>
We present a function <emphasis>showtext</emphasis> as follows that draws
the text represented by a given string in a manner that puts the center of
the drawing at the position (0, 0).

<informalexample><programlisting>
fun showtext {l:agz}
  (cr: !cairo_ref l, utf8: string): void = () where {
  var te : cairo_text_extents_t
  val () = cairo_text_extents (cr, utf8, te)
//
  val width = te.width
  and height = te.height
  val x_base = te.width / 2 + te.x_bearing
  and y_base = ~te.y_bearing / 2
//
  val (pf0 | ()) = cairo_save (cr)
//
  val () = cairo_rectangle (cr, ~width / 2, ~height/ 2, width, height)
  val () = cairo_set_source_rgb (cr, 0.5, 0.5, 1.0)
  val () = cairo_fill (cr)
//
  #define RAD 2.0
  val () = cairo_arc (cr, ~x_base, y_base, RAD, 0.0, 2*PI)
  val () = cairo_set_source_rgb (cr, 1.0, 0.0, 0.0) // red
  val () = cairo_fill (cr)
//
  val () = cairo_arc (cr, ~x_base+te.x_advance, y_base+te.y_advance, RAD, 0.0, 2*PI)
  val () = cairo_set_source_rgb (cr, 1.0, 0.0, 0.0) // red
  val () = cairo_fill (cr)
//
  val () = cairo_move_to (cr, ~x_base, y_base)
  val () = cairo_text_path (cr, utf8)
  val () = cairo_set_source_rgb (cr, 0.25, 0.25, 0.25) // dark gray
  val () = cairo_fill (cr)
//
  val () = cairo_restore (pf0 | cr)
//
} // end of [showtext]
</programlisting></informalexample>

For instance, the following image is produced by calling
<emphasis>showtext</emphasis> (see <ulink
url="CODE/tutprog_showtext_dats.html"><filename>tutprog_showtext.dats</filename></ulink>
for the entire code):
</para>

<para>
<inlinemediaobject>
<imageobject>
<imagedata fileref="IMAGE/tutprog_showtext.png" format="PNG"/>
</imageobject>
</inlinemediaobject>
</para>

<para>
Given a string <emphasis>utf8</emphasis>, we can find out some properties
about the path that draws the text represented by the string as follows:
<informalexample><programlisting>
  var te : cairo_text_extents_t
  val () = cairo_text_extents (cr, utf8, te)
</programlisting></informalexample>

The type <emphasis>cairo_text_extents_t</emphasis> is defined as an
external struct type in ATS:
<informalexample><programlisting>
//
// This external struct type is originally defined in [cairo.h]:
//
typedef cairo_text_extents_t =
  $extype_struct "cairo_text_extents_t" of {
  x_bearing= double
, y_bearing= double
, width= double
, height= double
, x_advance= double
, y_advance= double
} // end of [cairo_text_extents_t]
</programlisting></informalexample>

and the function <emphasis>cairo_text_extents</emphasis> is given the
following type:

<informalexample><programlisting>
fun cairo_text_extents {l:agz} (
  cr: !cairo_ref l, utf8: string
, extents: &amp;cairo_text_extents_t? >> cairo_text_extents_t
) : void
</programlisting></informalexample>

In the above image depicting the text <emphasis>Top Secret</emphasis>, the
center of the left red dot is often referred to as the base point of the
text, which initiates the path that draws the text. The width and height of
the rectangle forming the background of the text are stored in the fields
of <emphasis>width</emphasis> and <emphasis>height</emphasis> of the struct
in <emphasis>te</emphasis>, respectively. The vector is (x_bearing,
y_bearing) from the base point to the upper left corner of the rectangle,
and the vector is (x_advance, y_advance) from the base point to the center
of the right red dot, which is the suggested base point for the text that
follows.

The function call <emphasis>cairo_text_path(cr, utf8)</emphasis> generates
a path that draws the text represented by <emphasis>utf8</emphasis>, where
the function <emphasis>cairo_text_path</emphasis> is given the following
type in ATS:

<informalexample><programlisting>
fun cairo_text_path {l:agz} (cr: !cairo_ref l, text: string): void
</programlisting></informalexample>

Note that a call to <emphasis>cairo_text_path</emphasis> followed by
a call to <emphasis>cairo_fill</emphasis> is essentially equivalent
to a call to <emphasis>cairo_show_text</emphasis>, which is given the
following type in ATS:

<informalexample><programlisting>
fun cairo_show_text {l:agz} (cr: !cairo_ref l, utf8: string): void
</programlisting></informalexample>

</para>

</sect1><!-- cairo_drawing_text -->

</chapter>

<!--
end of [cairo_basics.db]
-->

<!--
-->
