(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
 * ATS - Unleashing the Power of Types!
 *
 * Copyright (C) 2002-2008 Hongwei Xi, Boston University
 *
 * All rights reserved
 *
 * ATS is free software;  you can  redistribute it and/or modify it under
 * the terms of the GNU LESSER GENERAL PUBLIC LICENSE as published by the
 * Free Software Foundation; either version 2.1, or (at your option)  any
 * later version.
 * 
 * ATS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
 * for more details.
 * 
 * You  should  have  received  a  copy of the GNU General Public License
 * along  with  ATS;  see  the  file  COPYING.  If not, write to the Free
 * Software Foundation, 51  Franklin  Street,  Fifth  Floor,  Boston,  MA
 * 02110-1301, USA.
 *
 *)

(* ****** ****** *)

// July 2007
// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)

(* ****** ****** *)

staload "top.sats"

(* ****** ****** *)

datatype chars =
  | chars_nil | chars_cons of (int, int, chars)

assume charset_t = chars

//

implement
list_vt_of_charset (cs, tag) = let
  fun loop {n:nat} (
    cs: chars, n: int n
  , xs: list_vt (@(int, int, int), n)
  , tag: int
  ) : [m:nat] (int m, list_vt (@(int, int, int), m)) =
    case+ cs of
    | chars_nil () => (n, xs)
    | chars_cons (c1, c2, cs) => loop (cs, n+1, list_vt_cons (@(c1, c2, tag), xs), tag)
  // end of [loop]
in
  loop (cs, 0, list_vt_nil (), tag)
end // end of [list_vt_of_charset]

implement fprint_charset
  {m:file_mode} (pf_mod | fil, cs): void = let
  fun loop (fil: &FILE m, cs: chars): void = begin case+ cs of
    | chars_cons (c1, c2, cs) => begin
        fprintf (pf_mod | fil, "(%d,%d)", @(c1, c2));
        case+ cs of
        | chars_nil () => ()
        | chars_cons _ => (fprint_char (pf_mod | fil, ','); loop (fil, cs))
      end // end of [chars_cons]
    | chars_nil () => ()
  end // end of [loop]
in
  fprint_string (pf_mod | fil, "'[");
  loop (fil, cs);
  fprint_string (pf_mod | fil, "]")
end // end of [fprint_charset]

implement print_charset (cs) = print_mac (fprint_charset, cs)
implement prerr_charset (cs) = prerr_mac (fprint_charset, cs)

(* ****** ****** *)

implement
charset_is_nil (cs) = (case+ cs of chars_nil () => true | _ => false)
// end of [charset_is_nil]

(* ****** ****** *)

implement compare_charset_charset (cs1, cs2) = let
  #define LT ~1; #define GT 1; #define EQ 0
  fun comp (cs1: chars, cs2: chars): Sgn =
    case+ (cs1, cs2) of
    | (chars_nil (), chars_nil ()) => EQ
    | (chars_nil (), _) => LT
    | (_, chars_nil ()) => GT
    | (chars_cons (a1, b1, cs1), chars_cons (a2, b2, cs2)) => let
        val t = compare (a1, a2)
      in
        if t = EQ then let
          val r = compare (b1, b2)
        in
          if r = EQ then comp (cs1, cs2)
          else r
        end else t
      end // end of [let]
  // end of [comp]
in
  comp (cs1, cs2)
end // end of [compare_charset_charset]

(* ****** ****** *)

#define CHAR_NUL 0
#define CHAR_MAX 0x10ffff // must be less than MAX_INT
#define CHAR_EOF ~1

implement charset_nil = chars_nil ()
implement charset_all = chars_cons (CHAR_NUL, CHAR_MAX, chars_nil ())

// every char satisfying c <= -1 is treated as CHAR_EOF
implement charset_eof = chars_cons (CHAR_EOF, CHAR_EOF, chars_nil ())

(* ****** ****** *)

implement charset_interval (c1, c2) = begin
  if c1 <= c2 then
    chars_cons (c1, c2, chars_nil ())
  else
    chars_cons (c2, c1, chars_nil ())
  // end of [if]
end // end of [charset_interval]

implement charset_singleton c = chars_cons (c, c, chars_nil ())

//

implement charset_complement (cs) = let
  fun aux (start: int, cs: chars): chars = case+ cs of
    | chars_nil () => begin
        if start <= CHAR_MAX then chars_cons (start, CHAR_MAX, chars_nil ())
        else chars_nil ()
      end // end of [begin]
    | chars_cons (c1, c2, cs) => chars_cons (start, c1-1, aux (c2+1, cs))
  // end of [aux]
in
  case+ cs of
  | chars_cons (CHAR_EOF, j, cs1) => aux (succ j, cs1)
  | _ => aux (CHAR_EOF, cs)
end // end of [charset_complement]

//

implement charset_is_member
  (cs, c0) = loop (cs, c0) where {
  fun loop (cs: chars, c0: int): bool = begin
    case+ cs of
    | chars_cons (c1, c2, cs) => begin
        if c1 <= c0 then
          (if c0 <= c2 then true else loop (cs, c0))
        else loop (cs, c0)
      end // end of [chars_cons]
    | chars_nil () => false
  end // end of [loop]
} // end of [charset_is_member]

//

implement charset_is_joint
  (cs1, cs2) = loop (cs1, cs2) where {
  fun loop (cs1: chars, cs2: chars): bool = begin
    case+ (cs1, cs2) of
    | (chars_cons (c11, c12, cs10), chars_cons (c21, c22, cs20)) => begin
        if c21 < c11 then loop (cs2, cs1)
        else if c12 < c21 then loop (cs10, cs2)
        else true
      end // end of [chars_cons]
    | (chars_nil (), _) => false
    | (_, chars_nil ()) => false
  end // end of [loop]
} // end of [charset_is_joint]

//

implement charset_union (cs1, cs2) = let
  fun loop (cs1: chars, cs2: chars)
    : chars = begin case+ (cs1, cs2) of
    | (chars_cons (c11, c12, cs10),
       chars_cons (c21, c22, cs20)) => begin
        if c21 < c11 then begin
          loop (cs2, cs1)
        end else if 1 < c21 - c12 then begin
          chars_cons (c11, c12, loop (cs10, cs2))
        end else if c12 <= c22 then begin
          loop (chars_cons (c11, c22, cs20), cs10)
        end else begin
          loop (cs1, cs20)
        end
      end // end of [chars_cons _, chars_cons _]
    | (chars_nil (), _) => cs2
    | (_, chars_nil ()) => cs1
  end // end of [loop]
in
  loop (cs1, cs2)
end // end of [charset_union]

//

#if 1
implement charset_intersect (cs1, cs2) =
  charset_complement (charset_union (charset_complement cs1, charset_complement cs2))
#else
// FIXME: there is something wrong with this
implement charset_intersect (cs1, cs2) = let
  fun loop (cs1: chars, cs2: chars)
    : chars = begin case+ (cs1, cs2) of
    | (chars_cons (c11, c12, cs10),
       chars_cons (c21, c22, cs20)) => begin
        if c21 < c11 then begin
          loop (cs2, cs1)
        end else if c12 < c21 then begin
          loop (cs10, cs2)
        end else if c12 <= c22 then begin
          chars_cons (c21, c12, loop (cs10, cs2))
        end else begin
          chars_cons (c21, c22, loop (cs1, cs20))
        end
      end // end of [chars_cons]
    | (chars_nil (), _) => chars_nil ()
    | (_, chars_nil ()) => chars_nil ()
  end // end of [loop]
in
  loop (cs1, cs2)
end // end of [charset_intersect]
#endif

#if 1
implement charset_difference (cs1, cs2) =
  charset_complement (charset_union (charset_complement cs1, cs2))
#else
// FIXME: there is something wrong with this
implement charset_difference (cs1, cs2) = let
  fun loop (cs1: chars, cs2: chars)
    : chars = begin case+ (cs1, cs2) of
    | (chars_cons (c11, c12, cs10),
       chars_cons (c21, c22, cs20)) => begin
        if c12 < c21 then begin
          loop (cs10, cs2)
        end else if c22 < c11 then begin
          loop (cs1, cs20)
        end else if c12 <= c22 then begin
          if c11 < c21 then begin
            chars_cons (c11, c21-1, loop (cs10, cs2))
          end else begin
            loop (cs10, cs2)
          end // end of [if]
        end else begin // c22 < c12
          if c11 < c21 then begin chars_cons
            (c11, c21-1, loop (chars_cons (c22+1, c12, cs10), cs20))
          end else begin
            loop (chars_cons (c22+1, c12, cs10), cs20)
          end // end of [if]
        end
      end // end of [chars_cons _, chars_cons _]
    | (chars_nil (), _) => chars_nil ()
    | (_, chars_nil ()) => cs1
  end // end of [loop]
in
   loop (cs1, cs2)
end // end of [charset_difference]
#endif

(* ****** ****** *)
(* Unicode classes from XML,
 * adapted from Ulex source code
 *)

fn{} charset_cons (x: @(int, int), y: chars):<> chars = chars_cons (x.0, x.1, y)
#define :: charset_cons

implement
charset_base_char =
  (0x0041,0x005A)::(0x0061,0x007A)::(0x00C0,0x00D6)::(0x00D8,0x00F6)
::(0x00F8,0x00FF)::(0x0100,0x0131)::(0x0134,0x013E)::(0x0141,0x0148)
::(0x014A,0x017E)::(0x0180,0x01C3)::(0x01CD,0x01F0)::(0x01F4,0x01F5)
::(0x01FA,0x0217)::(0x0250,0x02A8)::(0x02BB,0x02C1)::(0x0386,0x0386)
::(0x0388,0x038A)::(0x038C,0x038C)::(0x038E,0x03A1)::(0x03A3,0x03CE)
::(0x03D0,0x03D6)::(0x03DA,0x03DA)::(0x03DC,0x03DC)::(0x03DE,0x03DE)
::(0x03E0,0x03E0)::(0x03E2,0x03F3)
::(0x0401,0x040C)::(0x040E,0x044F)::(0x0451,0x045C)::(0x045E,0x0481)
::(0x0490,0x04C4)::(0x04C7,0x04C8)::(0x04CB,0x04CC)::(0x04D0,0x04EB)
::(0x04EE,0x04F5)::(0x04F8,0x04F9)::(0x0531,0x0556)::(0x0559,0x0559)
::(0x0561,0x0586)::(0x05D0,0x05EA)::(0x05F0,0x05F2)::(0x0621,0x063A)
::(0x0641,0x064A)::(0x0671,0x06B7)::(0x06BA,0x06BE)::(0x06C0,0x06CE)
::(0x06D0,0x06D3)::(0x06D5,0x06D5)::(0x06E5,0x06E6)::(0x0905,0x0939)
::(0x093D,0x093D)
::(0x0958,0x0961)::(0x0985,0x098C)::(0x098F,0x0990)::(0x0993,0x09A8)
::(0x09AA,0x09B0)::(0x09B2,0x09B2)::(0x09B6,0x09B9)::(0x09DC,0x09DD)
::(0x09DF,0x09E1)::(0x09F0,0x09F1)::(0x0A05,0x0A0A)::(0x0A0F,0x0A10)
::(0x0A13,0x0A28)::(0x0A2A,0x0A30)::(0x0A32,0x0A33)::(0x0A35,0x0A36)
::(0x0A38,0x0A39)::(0x0A59,0x0A5C)::(0x0A5E,0x0A5E)::(0x0A72,0x0A74)
::(0x0A85,0x0A8B)::(0x0A8D,0x0A8D)::(0x0A8F,0x0A91)::(0x0A93,0x0AA8)
::(0x0AAA,0x0AB0)::(0x0AB2,0x0AB3)::(0x0AB5,0x0AB9)::(0x0ABD,0x0ABD)
::(0x0AE0,0x0AE0)
::(0x0B05,0x0B0C)::(0x0B0F,0x0B10)::(0x0B13,0x0B28)::(0x0B2A,0x0B30)
::(0x0B32,0x0B33)::(0x0B36,0x0B39)::(0x0B3D,0x0B3D)::(0x0B5C,0x0B5D)
::(0x0B5F,0x0B61)::(0x0B85,0x0B8A)::(0x0B8E,0x0B90)::(0x0B92,0x0B95)
::(0x0B99,0x0B9A)::(0x0B9C,0x0B9C)::(0x0B9E,0x0B9F)::(0x0BA3,0x0BA4)
::(0x0BA8,0x0BAA)::(0x0BAE,0x0BB5)::(0x0BB7,0x0BB9)::(0x0C05,0x0C0C)
::(0x0C0E,0x0C10)::(0x0C12,0x0C28)::(0x0C2A,0x0C33)::(0x0C35,0x0C39)
::(0x0C60,0x0C61)::(0x0C85,0x0C8C)::(0x0C8E,0x0C90)::(0x0C92,0x0CA8)
::(0x0CAA,0x0CB3)::(0x0CB5,0x0CB9)::(0x0CDE,0x0CDE)::(0x0CE0,0x0CE1)
::(0x0D05,0x0D0C)::(0x0D0E,0x0D10)::(0x0D12,0x0D28)::(0x0D2A,0x0D39)
::(0x0D60,0x0D61)::(0x0E01,0x0E2E)::(0x0E30,0x0E30)::(0x0E32,0x0E33)
::(0x0E40,0x0E45)::(0x0E81,0x0E82)::(0x0E84,0x0E84)::(0x0E87,0x0E88)
::(0x0E8A,0x0E8A)
::(0x0E8D,0x0E8D)::(0x0E94,0x0E97)::(0x0E99,0x0E9F)::(0x0EA1,0x0EA3)
::(0x0EA5,0x0EA5)
::(0x0EA7,0x0EA7)::(0x0EAA,0x0EAB)::(0x0EAD,0x0EAE)::(0x0EB0,0x0EB0)
::(0x0EB2,0x0EB3)
::(0x0EBD,0x0EBD)::(0x0EC0,0x0EC4)::(0x0F40,0x0F47)::(0x0F49,0x0F69)
::(0x10A0,0x10C5)::(0x10D0,0x10F6)::(0x1100,0x1100)::(0x1102,0x1103)
::(0x1105,0x1107)::(0x1109,0x1109)::(0x110B,0x110C)::(0x110E,0x1112)
::(0x113C,0x113C)
::(0x113E,0x113E)::(0x1140,0x1140)::(0x114C,0x114C)::(0x114E,0x114E)
::(0x1150,0x1150)::(0x1154,0x1155)::(0x1159,0x1159)
::(0x115F,0x1161)::(0x1163,0x1163)::(0x1165,0x1165)::(0x1167,0x1167)
::(0x1169,0x1169)::(0x116D,0x116E)
::(0x1172,0x1173)::(0x1175,0x1175)::(0x119E,0x119E)::(0x11A8,0x11A8)
::(0x11AB,0x11AB)::(0x11AE,0x11AF)
::(0x11B7,0x11B8)::(0x11BA,0x11BA)::(0x11BC,0x11C2)::(0x11EB,0x11EB)
::(0x11F0,0x11F0)::(0x11F9,0x11F9)
::(0x1E00,0x1E9B)::(0x1EA0,0x1EF9)::(0x1F00,0x1F15)::(0x1F18,0x1F1D)
::(0x1F20,0x1F45)::(0x1F48,0x1F4D)::(0x1F50,0x1F57)::(0x1F59,0x1F59)
::(0x1F5B,0x1F5B)
::(0x1F5D,0x1F5D)::(0x1F5F,0x1F7D)::(0x1F80,0x1FB4)::(0x1FB6,0x1FBC)
::(0x1FBE,0x1FBE)
::(0x1FC2,0x1FC4)::(0x1FC6,0x1FCC)::(0x1FD0,0x1FD3)::(0x1FD6,0x1FDB)
::(0x1FE0,0x1FEC)::(0x1FF2,0x1FF4)::(0x1FF6,0x1FFC)::(0x2126,0x2126)
::(0x212A,0x212B)::(0x212E,0x212E)::(0x2180,0x2182)::(0x3041,0x3094)
::(0x30A1,0x30FA)::(0x3105,0x312C)::(0xAC00,0xD7A3)::chars_nil
// end of [charset_base_char]

implement
charset_ideographic =
  (0x3007,0x3007)
::(0x3021,0x3029)
::(0x4E00,0x9FA5)
::chars_nil
// end of [charset_ideographic]

implement
charset_combining_char =
  (0x0300,0x0345)::(0x0360,0x0361)::(0x0483,0x0486)::(0x0591,0x05A1)
::(0x05A3,0x05B9)::(0x05BB,0x05BD)::(0x05BF,0x05BF)::(0x05C1,0x05C2)
::(0x05C4,0x05C4)::(0x064B,0x0652)::(0x0670,0x0670)::(0x06D6,0x06DC)
::(0x06DD,0x06DF)::(0x06E0,0x06E4)::(0x06E7,0x06E8)::(0x06EA,0x06ED)
::(0x0901,0x0903)::(0x093C,0x093C)::(0x093E,0x094C)::(0x094D,0x094D)
::(0x0951,0x0954)::(0x0962,0x0963)::(0x0981,0x0983)::(0x09BC,0x09BC)
::(0x09BE,0x09BE)::(0x09BF,0x09BF)::(0x09C0,0x09C4)::(0x09C7,0x09C8)
::(0x09CB,0x09CD)::(0x09D7,0x09D7)::(0x09E2,0x09E3)::(0x0A02,0x0A02)
::(0x0A3C,0x0A3C)::(0x0A3E,0x0A3E)::(0x0A3F,0x0A3F)::(0x0A40,0x0A42)
::(0x0A47,0x0A48)::(0x0A4B,0x0A4D)::(0x0A70,0x0A71)::(0x0A81,0x0A83)
::(0x0ABC,0x0ABC)::(0x0ABE,0x0AC5)::(0x0AC7,0x0AC9)::(0x0ACB,0x0ACD)
::(0x0B01,0x0B03)::(0x0B3C,0x0B3C)::(0x0B3E,0x0B43)::(0x0B47,0x0B48)
::(0x0B4B,0x0B4D)::(0x0B56,0x0B57)::(0x0B82,0x0B83)::(0x0BBE,0x0BC2)
::(0x0BC6,0x0BC8)::(0x0BCA,0x0BCD)::(0x0BD7,0x0BD7)::(0x0C01,0x0C03)
::(0x0C3E,0x0C44)::(0x0C46,0x0C48)::(0x0C4A,0x0C4D)::(0x0C55,0x0C56)
::(0x0C82,0x0C83)::(0x0CBE,0x0CC4)::(0x0CC6,0x0CC8)::(0x0CCA,0x0CCD)
::(0x0CD5,0x0CD6)::(0x0D02,0x0D03)::(0x0D3E,0x0D43)::(0x0D46,0x0D48)
::(0x0D4A,0x0D4D)::(0x0D57,0x0D57)::(0x0E31,0x0E31)::(0x0E34,0x0E3A)
::(0x0E47,0x0E4E)::(0x0EB1,0x0EB1)::(0x0EB4,0x0EB9)::(0x0EBB,0x0EBC)
::(0x0EC8,0x0ECD)::(0x0F18,0x0F19)::(0x0F35,0x0F35)::(0x0F37,0x0F37)
::(0x0F39,0x0F39)::(0x0F3E,0x0F3E)::(0x0F3F,0x0F3F)::(0x0F71,0x0F84)
::(0x0F86,0x0F8B)::(0x0F90,0x0F95)::(0x0F97,0x0F97)::(0x0F99,0x0FAD)
::(0x0FB1,0x0FB7)::(0x0FB9,0x0FB9)::(0x20D0,0x20DC)::(0x20E1,0x20E1)
::(0x302A,0x302F)::(0x3099,0x3099)::(0x309A,0x309A)::chars_nil
// end of [charset_combining_char]

implement
charset_digit =
  (0x0030,0x0039)::(0x0660,0x0669)::(0x06F0,0x06F9)::(0x0966,0x096F)::(0x09E6,0x09EF)
::(0x0A66,0x0A6F)::(0x0AE6,0x0AEF)::(0x0B66,0x0B6F)::(0x0BE7,0x0BEF)
::(0x0C66,0x0C6F)::(0x0CE6,0x0CEF)::(0x0D66,0x0D6F)::(0x0E50,0x0E59)
::(0x0ED0,0x0ED9)::(0x0F20,0x0F29)::chars_nil
// end of [charset_digit]

implement
charset_extender =
  (0x00B7,0x00B7)::(0x02D0,0x02D1)::(0x0387,0x0387)::(0x0640,0x0640)
::(0x0E46,0x0E46)::(0x0EC6,0x0EC6)::(0x3005,0x3005)::(0x3031,0x3035)
::(0x309D,0x309E)::(0x30FC,0x30FE)::chars_nil
// end of [charset_extender]

implement
charset_blank = (0x0009,0x000A)::(0x000D,0x000D)::(0x0020,0x0020)::chars_nil

implement
charset_letter = charset_union (charset_base_char, charset_ideographic)

(* Letters to be used in identifiers, as specified
   by ISO ....
   Data provided by John M. Skaller *)
implement
charset_tr8876_ident_char =
  (* ASCII *)
  (0x0041,0x005a)
::(0x0061,0x007a)

  (* Latin *)
::(0x00c0,0x00d6)
::(0x00d8,0x00f6)
::(0x00f8,0x01f5)
::(0x01fa,0x0217)
::(0x0250,0x02a8)

  (* Greek *)
::(0x0384,0x0384)
::(0x0388,0x038a)
::(0x038c,0x038c)
::(0x038e,0x03a1)
::(0x03a3,0x03ce)
::(0x03d0,0x03d6)
::(0x03da,0x03da)
::(0x03dc,0x03dc)
::(0x03de,0x03de)
::(0x03e0,0x03e0)
::(0x03e2,0x03f3)

  (* Cyrillic *)
::(0x0401,0x040d)
::(0x040f,0x044f)
::(0x0451,0x045c)
::(0x045e,0x0481)
::(0x0490,0x04c4)
::(0x04c7,0x04c4)
::(0x04cb,0x04cc)
::(0x04d0,0x04eb)
::(0x04ee,0x04f5)
::(0x04f8,0x04f9)

  (* Armenian *)
::(0x0531,0x0556)
::(0x0561,0x0587)
::(0x04d0,0x04eb)

  (* Hebrew *)
::(0x05d0,0x05ea)
::(0x05f0,0x05f4)

  (* Arabic *)
::(0x0621,0x063a)
::(0x0640,0x0652)
::(0x0670,0x06b7)
::(0x06ba,0x06be)
::(0x06c0,0x06ce)
::(0x06e5,0x06e7)

  (* Devanagari *)
::(0x0905,0x0939)
::(0x0958,0x0962)

  (* Bengali *)
::(0x0985,0x098c)
::(0x098f,0x0990)
::(0x0993,0x09a8)
::(0x09aa,0x09b0)
::(0x09b2,0x09b2)
::(0x09b6,0x09b9)
::(0x09dc,0x09dd)
::(0x09df,0x09e1)
::(0x09f0,0x09f1)

  (* Gurmukhi *)
::(0x0a05,0x0a0a)
::(0x0a0f,0x0a10)
::(0x0a13,0x0a28)
::(0x0a2a,0x0a30)
::(0x0a32,0x0a33)
::(0x0a35,0x0a36)
::(0x0a38,0x0a39)
::(0x0a59,0x0a5c)
::(0x0a5e,0x0a5e)

  (* Gunjarati *)
::(0x0a85,0x0a8b)
::(0x0a8d,0x0a8d)
::(0x0a8f,0x0a91)
::(0x0a93,0x0aa8)
::(0x0aaa,0x0ab0)
::(0x0ab2,0x0ab3)
::(0x0ab5,0x0ab9)
::(0x0ae0,0x0ae0)

  (* Oriya *)
::(0x0b05,0x0b0c)
::(0x0b0f,0x0b10)
::(0x0b13,0x0b28)
::(0x0b2a,0x0b30)
::(0x0b32,0x0b33)
::(0x0b36,0x0b39)
::(0x0b5c,0x0b5d)
::(0x0b5f,0x0b61)

  (* Tamil *)
::(0x0b85,0x0b8a)
::(0x0b8e,0x0b90)
::(0x0b92,0x0b95)
::(0x0b99,0x0b9a)
::(0x0b9c,0x0b9c)
::(0x0b9e,0x0b9f)
::(0x0ba3,0x0ba4)
::(0x0ba8,0x0baa)
::(0x0bae,0x0bb5)
::(0x0bb7,0x0bb9)

  (* Telugu *)
::(0x0c05,0x0c0c)
::(0x0c0e,0x0c10)
::(0x0c12,0x0c28)
::(0x0c2a,0x0c33)
::(0x0c35,0x0c39)
::(0x0c60,0x0c61)

  (* Kannada *)
::(0x0c85,0x0c8c)
::(0x0c8e,0x0c90)
::(0x0c92,0x0ca8)
::(0x0caa,0x0cb3)
::(0x0cb5,0x0cb9)
::(0x0ce0,0x0ce1)

  (* Malayam *)
::(0x0d05,0x0d0c)
::(0x0d0e,0x0d10)
::(0x0d12,0x0d28)
::(0x0d2a,0x0d39)
::(0x0d60,0x0d61)

  (* Thai *)
::(0x0e01,0x0e30)
::(0x0e32,0x0e33)
::(0x0e40,0x0e46)
::(0x0e4f,0x0e5b)

  (* Lao *)
::(0x0e81,0x0e82)
::(0x0e84,0x0e84)
::(0x0e87,0x0e88)
::(0x0e8a,0x0e8a)
::(0x0e0d,0x0e0d)
::(0x0e94,0x0e97)
::(0x0e99,0x0e9f)
::(0x0ea1,0x0ea3)
::(0x0ea5,0x0ea5)
::(0x0ea7,0x0ea7)
::(0x0eaa,0x0eab)
::(0x0ead,0x0eb0)
::(0x0eb2,0x0eb3)
::(0x0ebd,0x0ebd)
::(0x0ec0,0x0ec4)
::(0x0ec6,0x0ec6)

  (* Georgian *)
::(0x10a0,0x10c5)
::(0x10d0,0x10f6)

  (* Hangul Jamo *)
::(0x1100,0x1159)
::(0x1161,0x11a2)
::(0x11a8,0x11f9)
::(0x11d0,0x11f6)

  (* Latin extensions *)
::(0x1e00,0x1e9a)
::(0x1ea0,0x1ef9)

  (* Greek extended *)
::(0x1f00,0x1f15)
::(0x1f18,0x1f1d)
::(0x1f20,0x1f45)
::(0x1f48,0x1f4d)
::(0x1f50,0x1f57)
::(0x1f59,0x1f59)
::(0x1f5b,0x1f5b)
::(0x1f5d,0x1f5d)
::(0x1f5f,0x1f7d)
::(0x1f80,0x1fb4)
::(0x1fb6,0x1fbc)
::(0x1fc2,0x1fc4)
::(0x1fc6,0x1fcc)
::(0x1fd0,0x1fd3)
::(0x1fd6,0x1fdb)
::(0x1fe0,0x1fec)
::(0x1ff2,0x1ff4)
::(0x1ff6,0x1ffc)

  (* Hiragana *)
::(0x3041,0x3094)
::(0x309b,0x309e)

  (* Katakana *)
::(0x30a1,0x30fe)

  (* Bopmofo *)
::(0x3105,0x312c)

  (* CJK Unified Ideographs *)
::(0x4e00,0x9fa5)

  (* CJK Compatibility Ideographs *)
::(0xf900,0xfa2d)

  (* Arabic Presentation Forms *)
::(0xfb1f,0xfb36)
::(0xfb38,0xfb3c)
::(0xfb3e,0xfb3e)
::(0xfb40,0xfb41)
::(0xfb42,0xfb44)
::(0xfb46,0xfbb1)
::(0xfbd3,0xfd35)

  (* Arabic Presentation Forms-A *)
::(0xfd50,0xfd85)
::(0xfd92,0xfbc7)
::(0xfdf0,0xfdfb)

  (* Arabic Presentation Forms-B *)
::(0xfe70,0xfe72)
::(0xfe74,0xfe74)
::(0xfe76,0xfefc)

  (* Half width and Fullwidth Forms *)
::(0xff21,0xff3a)
::(0xff41,0xff5a)
::(0xff66,0xffbe)
::(0xffc2,0xffc7)
::(0xffca,0xffcf)
::(0xffd2,0xffd7)
::(0xffda,0xffdc)
::chars_nil
// end of [charset_tr8876_ident_char]

(* ****** ****** *)

(* end of [charset.dats] *)
